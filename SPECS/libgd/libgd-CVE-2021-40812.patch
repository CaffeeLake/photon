From e5c84f0b7a2e2cef8d8630bd8c26a2f859e959ff Mon Sep 17 00:00:00 2001
From: Pierre Joye <pierre.php@gmail.com>
Date: Tue, 7 Sep 2021 22:03:21 +0700
Subject: [PATCH 1/2] Partial fix for #750

---
 src/gd_bmp.c  | 33 ++++++++++++++++++++++++++++-----
 src/gd_webp.c | 42 +++++++++++++++++++++++++++++++++---------
 2 files changed, 61 insertions(+), 14 deletions(-)

diff --git a/src/gd_bmp.c b/src/gd_bmp.c
index e1194c54..c1b4d4ae 100644
--- a/src/gd_bmp.c
+++ b/src/gd_bmp.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include "gd.h"
 #include "gdhelpers.h"
+#include "gd_errors.h"
 #include "bmp.h"
 
 static int compress_row(unsigned char *uncompressed_row, int length);
@@ -39,6 +40,7 @@ static int bmp_read_1bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp
 static int bmp_read_4bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);
 static int bmp_read_8bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);
 static int bmp_read_rle(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info);
+static int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression);
 
 #define BMP_DEBUG(s)
 
@@ -87,8 +89,22 @@ BGD_DECLARE(void) gdImageBmp(gdImagePtr im, FILE *outFile, int compression)
 
 /*
 	Function: gdImageBmpCtx
+	Outputs the given image as BMP data, but using a <gdIOCtx> instead
+	of a file. See <gdImageBmp>.
+	Parameters:
+		im			- the image to save.
+		out 		- the <gdIOCtx> to write to.
+		compression - whether to apply RLE or not.
 */
 BGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
+{
+	_gdImageBmpCtx(im, out, compression);
+}
+
+/*
+	Function: _gdImageBmpCtx
+*/
+static int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
 {
 	int bitmap_size = 0, info_size, total_size, padding;
 	int i, row, xpos, pixel;
@@ -96,6 +112,7 @@ BGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
 	unsigned char *uncompressed_row = NULL, *uncompressed_row_start = NULL;
 	FILE *tmpfile_for_compression = NULL;
 	gdIOCtxPtr out_original = NULL;
+        int ret = 1;
 
 	/* No compression if its true colour or we don't support seek */
 	if (im->trueColor) {
@@ -203,8 +220,11 @@ BGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
 				}
 				bitmap_size += compressed_size;
 
-
-				gdPutBuf(uncompressed_row, compressed_size, out);
+                                if (gdPutBuf(uncompressed_row, compressed_size, out) != compressed_size){
+                                        gd_error("gd-bmp write error\n");
+                                        error = 1;
+                                        break;
+                                }
 				Putchar(BMP_RLE_COMMAND, out);
 				Putchar(BMP_RLE_ENDOFLINE, out);
 				bitmap_size += 2;
@@ -263,7 +283,10 @@ BGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
 			if (buffer_size == 0) {
 				break;
 			}
-			gdPutBuf(copy_buffer , buffer_size, out_original);
+			if (gdPutBuf(copy_buffer , buffer_size, out_original) != buffer_size) {
+				gd_error("gd-bmp write error\n");
+				error = 1;
+			}
 		}
 		gdFree(copy_buffer);
 
@@ -272,7 +295,7 @@ BGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)
 		out = out_original;
 		out_original = NULL;
 	}
-
+        ret = error;
 cleanup:
 	if (tmpfile_for_compression) {
 #ifdef _WIN32
@@ -286,7 +309,7 @@ cleanup:
 	if (out_original) {
 		out_original->gd_free(out_original);
 	}
-	return;
+	return ret;
 }
 
 static int compress_row(unsigned char *row, int length)
diff --git a/src/gd_webp.c b/src/gd_webp.c
index 98628cff..a78f93fc 100644
--- a/src/gd_webp.c
+++ b/src/gd_webp.c
@@ -105,21 +105,23 @@ gdImagePtr gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+        int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
 		gd_error("Paletter image not supported by webp");
-		return;
+		return 1;
 	}
 
 	if (quantization == -1) {
@@ -128,7 +130,7 @@ void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -153,11 +155,33 @@ void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
 		gd_error("gd-webp encoding failed");
 		goto freeargb;
 	}
-	gdPutBuf(out, out_size, outfile);
+        int res = gdPutBuf(out, out_size, outfile);
 	free(out);
+        if (res != out_size) {
+                gd_error("gd-webp write error\n");
+                ret = 1;
+        }
 
 freeargb:
 	gdFree(argb);
+
+return ret;
+}
+
+/*
+  Function: gdImageWebpCtx
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+  Parameters:
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+  Returns:
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+        _gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -169,7 +193,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quantization
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quantization);
+	_gdImageWebpCtx(im, out, quantization);
 	out->gd_free(out);
 }
 
@@ -182,7 +206,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -196,7 +220,7 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 
@@ -213,7 +237,7 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quantization
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quantization);
+	_gdImageWebpCtx(im, out, quantization);
 	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
